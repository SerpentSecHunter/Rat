#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Termux Bot Controller - Enhanced Professional Version
Advanced features with non-root alternatives
Author: AI Assistant
Version: 2.0
"""

import os
import sys
import json
import subprocess
import logging
import asyncio
import threading
import time
import hashlib
import shutil
from datetime import datetime, timedelta
from pathlib import Path
import zipfile
import tarfile

# Auto install packages
def install_packages():
    packages = [
        'python-telegram-bot==20.7', 
        'psutil', 
        'requests', 
        'aiofiles',
        'pillow',
        'qrcode[pil]',
        'cryptography'
    ]
    for pkg in packages:
        try:
            pkg_name = pkg.split('==')[0].replace('-', '_')
            if pkg_name == 'pillow':
                pkg_name = 'PIL'
            elif pkg_name == 'qrcode[pil]':
                pkg_name = 'qrcode'
            __import__(pkg_name)
        except ImportError:
            print(f"üîΩ Installing {pkg}...")
            subprocess.run([sys.executable, '-m', 'pip', 'install', pkg, '--quiet'])

install_packages()

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, InputFile
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes
import psutil
import requests
import qrcode
from PIL import Image
import io
import base64

# Enhanced logging setup
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('termux_bot.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class AdvancedTermuxBot:
    def __init__(self):
        self.bot_token = self.get_token()
        self.current_directory = os.path.expanduser('~')
        self.bot_active = True
        self.termux_api = self.check_termux_api()
        self.authorized_users = self.load_authorized_users()
        self.command_history = []
        self.max_history = 50
        self.root_available = self.check_root()
        self.admin_features = self.check_device_admin()
        
        # Create necessary directories
        self.setup_directories()
        
    def setup_directories(self):
        """Create necessary directories for bot operation"""
        dirs = ['downloads', 'uploads', 'logs', 'backups', 'temp']
        for d in dirs:
            os.makedirs(d, exist_ok=True)
    
    def get_token(self):
        if os.path.exists('bot_config.json'):
            try:
                with open('bot_config.json', 'r') as f:
                    config = json.load(f)
                    return config.get('bot_token')
            except:
                pass
        
        print("\n" + "üî•"*60)
        print("üöÄ TERMUX BOT CONTROLLER v2.0 - PROFESSIONAL EDITION")
        print("üî•"*60)
        print("üìã SETUP INSTRUCTIONS:")
        print("1Ô∏è‚É£  Open @BotFather di Telegram")
        print("2Ô∏è‚É£  Ketik /newbot dan buat bot baru")
        print("3Ô∏è‚É£  Pilih nama dan username untuk bot")
        print("4Ô∏è‚É£  Copy token yang diberikan BotFather")
        print("5Ô∏è‚É£  Paste token dibawah ini")
        print("üî•"*60)
        
        token = input("ü§ñ Paste Bot Token: ").strip()
        
        config = {
            'bot_token': token,
            'created': datetime.now().isoformat(),
            'version': '2.0'
        }
        with open('bot_config.json', 'w') as f:
            json.dump(config, f, indent=2)
            
        return token
    
    def load_authorized_users(self):
        """Load authorized users from config"""
        try:
            with open('authorized_users.json', 'r') as f:
                return json.load(f)
        except:
            return []
    
    def save_authorized_users(self):
        """Save authorized users to config"""
        with open('authorized_users.json', 'w') as f:
            json.dump(self.authorized_users, f, indent=2)
    
    def check_termux_api(self):
        """Check Termux API availability with better error handling"""
        try:
            # Check if termux-api commands exist
            commands_to_check = ['termux-battery-status', 'termux-camera-info', 'termux-sensor']
            available_commands = 0
            
            for cmd in commands_to_check:
                try:
                    result = subprocess.run(['which', cmd], capture_output=True, timeout=3)
                    if result.returncode == 0:
                        available_commands += 1
                except:
                    continue
            
            # Consider API available if at least 2 commands are found
            return available_commands >= 2
        except Exception as e:
            logger.error(f"Error checking Termux API: {e}")
            return False
    
    def check_root(self):
        """Check if device has root access with better error handling"""
        try:
            # Method 1: Check for su command
            result = subprocess.run(['which', 'su'], capture_output=True, timeout=3)
            if result.returncode != 0:
                return False
            
            # Method 2: Try to execute a simple root command with timeout
            try:
                test_result = subprocess.run(['timeout', '3', 'su', '-c', 'id'], 
                                           capture_output=True, timeout=5)
                return test_result.returncode == 0 and 'uid=0' in test_result.stdout.decode()
            except:
                # Method 3: Check if we can read root-only files
                try:
                    with open('/data/system/users/0/settings_system.xml', 'r') as f:
                        return True
                except:
                    return False
                    
        except Exception as e:
            logger.error(f"Error checking root access: {e}")
            return False
    
    def check_device_admin(self):
        """Check for device admin alternatives with error handling"""
        try:
            alternatives = []
            
            # Check for various system access methods
            access_checks = [
                ('/proc/version', 'proc_access'),
                ('/sys/class/power_supply', 'power_access'),
                ('/sys/class/net', 'network_access'),
                ('/proc/meminfo', 'memory_access'),
                ('/proc/cpuinfo', 'cpu_access')
            ]
            
            for path, access_type in access_checks:
                try:
                    if os.path.exists(path) and os.access(path, os.R_OK):
                        alternatives.append(access_type)
                except:
                    continue
            
            # Check for notification access (if termux-api available)
            if self.termux_api:
                try:
                    result = subprocess.run(['termux-notification-list'], 
                                          capture_output=True, timeout=3)
                    if result.returncode == 0:
                        alternatives.append('notification_access')
                except:
                    pass
            
            return alternatives
            
        except Exception as e:
            logger.error(f"Error checking device admin alternatives: {e}")
            return []
    
    def is_authorized(self, user_id):
        """Check if user is authorized"""
        return len(self.authorized_users) == 0 or user_id in self.authorized_users
    
    def create_main_keyboard(self):
        """Create enhanced main menu keyboard"""
        keyboard = [
            [
                InlineKeyboardButton("üíª Terminal Pro", callback_data="terminal"),
                InlineKeyboardButton("üìä System Monitor", callback_data="sysinfo")
            ],
            [
                InlineKeyboardButton("üìÅ File Manager", callback_data="files"),
                InlineKeyboardButton("üåê Network Tools", callback_data="network")
            ],
            [
                InlineKeyboardButton("üì± Device Control", callback_data="device"),
                InlineKeyboardButton("üîß System Tools", callback_data="system_tools")
            ]
        ]
        
        if self.termux_api:
            keyboard.append([
                InlineKeyboardButton("üì∑ Camera Pro", callback_data="camera"),
                InlineKeyboardButton("üìç GPS & Sensors", callback_data="sensors")
            ])
        
        if self.root_available:
            keyboard.append([
                InlineKeyboardButton("üëë Root Manager", callback_data="root_manager")
            ])
        else:
            keyboard.append([
                InlineKeyboardButton("üîì Non-Root Tools", callback_data="nonroot_tools")
            ])
            
        keyboard.extend([
            [
                InlineKeyboardButton("üõ°Ô∏è Security", callback_data="security"),
                InlineKeyboardButton("üì¶ Package Manager", callback_data="packages")
            ],
            [
                InlineKeyboardButton("‚öôÔ∏è Settings", callback_data="settings"),
                InlineKeyboardButton("üìñ Help", callback_data="help")
            ]
        ])
        
        return InlineKeyboardMarkup(keyboard)
    
    def get_system_stats(self):
        """Get system stats with fallback methods for Android/Termux"""
        stats = {
            'cpu_percent': 0,
            'memory_percent': 0,
            'memory_used': 0,
            'memory_total': 0
        }
        
        try:
            # Try to get CPU usage
            stats['cpu_percent'] = psutil.cpu_percent(interval=0.1)
        except (PermissionError, OSError):
            try:
                # Fallback: use /proc/loadavg
                with open('/proc/loadavg', 'r') as f:
                    load_avg = float(f.read().split()[0])
                    stats['cpu_percent'] = min(load_avg * 25, 100)  # Rough estimate
            except:
                stats['cpu_percent'] = 0
        
        try:
            # Try to get memory info
            memory = psutil.virtual_memory()
            stats['memory_percent'] = memory.percent
            stats['memory_used'] = memory.used
            stats['memory_total'] = memory.total
        except (PermissionError, OSError):
            try:
                # Fallback: use /proc/meminfo
                with open('/proc/meminfo', 'r') as f:
                    meminfo = {}
                    for line in f:
                        parts = line.split()
                        if len(parts) >= 2:
                            meminfo[parts[0][:-1]] = int(parts[1]) * 1024  # Convert kB to bytes
                    
                    total = meminfo.get('MemTotal', 0)
                    available = meminfo.get('MemAvailable', meminfo.get('MemFree', 0))
                    used = total - available
                    
                    stats['memory_total'] = total
                    stats['memory_used'] = used
                    stats['memory_percent'] = (used / total * 100) if total > 0 else 0
            except:
                stats['memory_percent'] = 0
                stats['memory_used'] = 0
                stats['memory_total'] = 0
        
        return stats

    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        
        if not self.is_authorized(user_id):
            await update.message.reply_text(
                "üö´ **ACCESS DENIED**\n\nYou are not authorized to use this bot.",
                parse_mode='Markdown'
            )
            return
        
        # System status check with error handling
        try:
            stats = self.get_system_stats()
            cpu_percent = stats['cpu_percent']
            memory_percent = stats['memory_percent']
        except Exception as e:
            logger.error(f"Error getting system stats: {e}")
            cpu_percent = 0
            memory_percent = 0
        
        api_status = "üü¢ Active" if self.termux_api else "üî¥ Install Required"
        root_status = "üëë Available" if self.root_available else "üîì Non-Root Mode"
        
        message = f"""
üî• **TERMUX BOT CONTROLLER v2.0**
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üëã **Welcome, {update.effective_user.first_name}!**

üìä **System Status:**
‚î£ ü§ñ Bot: üü¢ **Online & Ready**
‚î£ üîå Termux API: {api_status}
‚î£ üëë Root Access: {root_status}
‚î£ üíª CPU: **{cpu_percent:.1f}%**
‚î£ üß† RAM: **{memory_percent:.1f}%**
‚îó üìÅ Directory: `{os.path.basename(self.current_directory)}`

üöÄ **New Features v2.0:**
‚î£ üåê **Advanced Network Tools**
‚î£ üõ°Ô∏è **Security & Encryption**
‚î£ üì¶ **Smart Package Manager**
‚î£ üîì **Non-Root Alternatives**
‚î£ üì± **Enhanced Device Control**
‚îó üíª **Professional Terminal**

‚ö° **Quick Actions:**
{f"‚î£ üì∑ Camera, üîã Battery, üìç GPS" if self.termux_api else "‚î£ ‚ö†Ô∏è Install Termux:API for hardware features"}
{f"‚î£ üëë Root operations available" if self.root_available else "‚î£ üîì Non-root tools active"}
‚îó üí° All features optimized for your device

üéØ **Select a feature to begin!**
        """
        
        await update.message.reply_text(
            message,
            reply_markup=self.create_main_keyboard(),
            parse_mode='Markdown'
        )
    
    async def button_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        await query.answer()
        
        user_id = update.effective_user.id
        if not self.is_authorized(user_id):
            await query.edit_message_text("üö´ Access denied")
            return
        
        handlers = {
            "terminal": self.show_terminal_pro,
            "sysinfo": self.show_system_monitor,
            "files": self.show_file_manager,
            "network": self.show_network_tools,
            "device": self.show_device_control,
            "system_tools": self.show_system_tools,
            "camera": self.show_camera_pro,
            "sensors": self.show_sensors,
            "root_manager": self.show_root_manager,
            "nonroot_tools": self.show_nonroot_tools,
            "security": self.show_security_tools,
            "packages": self.show_package_manager,
            "settings": self.show_settings,
            "help": self.show_help,
            "main_menu": self.show_main_menu,
            # File operations
            "upload_file": self.handle_file_upload,
            "download_file": self.handle_file_download,
            "compress_files": self.compress_files,
            "backup_system": self.backup_system,
            # Network operations
            "scan_network": self.scan_network,
            "check_ports": self.check_ports,
            "speed_test": self.network_speed_test,
            "wifi_info": self.show_wifi_info,
            # System operations
            "process_manager": self.show_process_manager,
            "service_manager": self.show_service_manager,
            "log_viewer": self.show_log_viewer,
            "cleanup_system": self.cleanup_system,
        }
        
        handler = handlers.get(query.data)
        if handler:
            await handler(query)
        else:
            await query.edit_message_text("üö´ Feature not implemented yet")
    
    async def show_main_menu(self, query):
        try:
            stats = self.get_system_stats()
            cpu = stats['cpu_percent']
            ram = stats['memory_percent']
        except:
            cpu = ram = 0
        
        message = f"""
üî• **MAIN MENU - TERMUX BOT v2.0**
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìä **Quick Status:**
‚î£ üíª CPU: **{cpu:.1f}%** | üß† RAM: **{ram:.1f}%**
‚î£ üìÅ Path: `{os.path.basename(self.current_directory)}`
‚îó üïê Time: **{datetime.now().strftime('%H:%M:%S')}**

üéØ **Choose your tool:**
        """
        
        await query.edit_message_text(
            message,
            reply_markup=self.create_main_keyboard(),
            parse_mode='Markdown'
        )
    
    async def show_terminal_pro(self, query):
        recent_commands = self.command_history[-5:] if self.command_history else ["No recent commands"]
        
        message = f"""
üíª **TERMINAL PRO MODE**
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìç **Current Directory:**
`{self.current_directory}`

üìä **Terminal Status:**
‚î£ üîÑ History: **{len(self.command_history)} commands**
‚î£ üëë Root: **{'Available' if self.root_available else 'Not Available'}**
‚îó üåê Network: **Connected**

üìù **Recent Commands:**
{chr(10).join([f"‚î£ `{cmd[:40]}...`" if len(cmd) > 40 else f"‚î£ `{cmd}`" for cmd in recent_commands[-3:]])}

üöÄ **Enhanced Features:**
‚î£ üíæ **Command History & Favorites**
‚î£ üìÅ **Smart Directory Navigation**
‚î£ üîÑ **Auto-completion Suggestions**
‚î£ üìä **Real-time Process Monitoring**
‚îó ‚ö° **Batch Command Execution**

üí° **Power Commands:**
```bash
# System Info
neofetch || screenfetch
htop || top

# Network
ss -tuln
netstat -an
ifconfig || ip addr

# Files & Processes
find / -name "*.apk" 2>/dev/null
ps aux | grep -v grep
du -sh */ | sort -hr
```

‚ö° **Type any command to execute!**
        """
        
        keyboard = [
            [
                InlineKeyboardButton("üìä Process Monitor", callback_data="process_manager"),
                InlineKeyboardButton("üìÅ Quick Nav", callback_data="files")
            ],
            [
                InlineKeyboardButton("üîÑ Command History", callback_data="cmd_history"),
                InlineKeyboardButton("‚ö° Batch Execute", callback_data="batch_cmd")
            ],
            [InlineKeyboardButton("üîô Main Menu", callback_data="main_menu")]
        ]
        
        await query.edit_message_text(
            message,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
    
    async def show_system_monitor(self, query):
        await query.edit_message_text("üìä Analyzing system performance...")
        
        try:
            # Enhanced system analysis with error handling
            try:
                stats = self.get_system_stats()
                cpu_percent = stats['cpu_percent']
                memory_percent = stats['memory_percent']
                memory_used = stats['memory_used']
                memory_total = stats['memory_total']
            except Exception as e:
                logger.error(f"Error getting system stats: {e}")
                cpu_percent = 0
                memory_percent = 0
                memory_used = 0
                memory_total = 0
            
            try:
                cpu_count = psutil.cpu_count() or 1
            except:
                cpu_count = 1
            
            try:
                disk = psutil.disk_usage('/')
            except:
                # Fallback for disk usage
                try:
                    result = subprocess.run(['df', '/'], capture_output=True, text=True, timeout=5)
                    if result.returncode == 0:
                        lines = result.stdout.strip().split('\n')
                        if len(lines) > 1:
                            parts = lines[1].split()
                            if len(parts) >= 4:
                                total = int(parts[1]) * 1024  # Convert KB to bytes
                                used = int(parts[2]) * 1024
                                free = int(parts[3]) * 1024
                                
                                class DiskUsage:
                                    def __init__(self, total, used, free):
                                        self.total = total
                                        self.used = used
                                        self.free = free
                                
                                disk = DiskUsage(total, used, free)
                            else:
                                raise Exception("Invalid df output")
                        else:
                            raise Exception("No df data")
                    else:
                        raise Exception("df command failed")
                except Exception as e:
                    logger.error(f"Error getting disk usage: {e}")
                    class DiskUsage:
                        def __init__(self):
                            self.total = 0
                            self.used = 0
                            self.free = 0
                    disk = DiskUsage()
            
            try:
                boot_time = psutil.boot_time()
                uptime = datetime.now() - datetime.fromtimestamp(boot_time)
            except:
                try:
                    # Fallback: use /proc/uptime
                    with open('/proc/uptime', 'r') as f:
                        uptime_seconds = float(f.read().split()[0])
                        uptime = timedelta(seconds=uptime_seconds)
                except:
                    uptime = timedelta(0)
            
            # Network stats with fallback
            try:
                net_io = psutil.net_io_counters()
                bytes_sent = net_io.bytes_sent
                bytes_recv = net_io.bytes_recv
                packets_sent = net_io.packets_sent
                packets_recv = net_io.packets_recv
            except:
                bytes_sent = bytes_recv = packets_sent = packets_recv = 0
            
            # Process count with fallback
            try:
                processes = len(psutil.pids())
            except:
                try:
                    result = subprocess.run(['ps', '-A'], capture_output=True, text=True, timeout=5)
                    if result.returncode == 0:
                        processes = len(result.stdout.strip().split('\n')) - 1  # Exclude header
                    else:
                        processes = 0
                except:
                    processes = 0
            
            # Temperature (if available)
            temp_info = "N/A"
            try:
                if self.termux_api:
                    temp_result = subprocess.run(['termux-sensor', '-s', 'temperature'], 
                                               capture_output=True, text=True, timeout=5)
                    if temp_result.returncode == 0:
                        temp_data = json.loads(temp_result.stdout)
                        temp_info = f"{temp_data.get('temperature', 'N/A')}¬∞C"
            except:
                # Try thermal zone fallback
                try:
                    thermal_files = ['/sys/class/thermal/thermal_zone0/temp',
                                   '/sys/class/thermal/thermal_zone1/temp']
                    for thermal_file in thermal_files:
                        if os.path.exists(thermal_file):
                            with open(thermal_file, 'r') as f:
                                temp_millicelsius = int(f.read().strip())
                                temp_celsius = temp_millicelsius / 1000
                                temp_info = f"{temp_celsius:.1f}¬∞C"
                                break
                except:
                    pass
            
            # Create enhanced progress bars
            cpu_bar = self.create_progress_bar(cpu_percent, 25, "üî•")
            ram_bar = self.create_progress_bar(memory_percent, 25, "üß†")
            disk_percent = (disk.used/disk.total*100) if disk.total > 0 else 0
            disk_bar = self.create_progress_bar(disk_percent, 25, "üíæ")
            
            message = f"""
üìä **SYSTEM PERFORMANCE MONITOR**
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üñ•Ô∏è **CPU Performance:**
{cpu_bar}
‚î£ Cores: **{cpu_count}** | Usage: **{cpu_percent:.1f}%**
‚îó Temperature: **{temp_info}**

üß† **Memory Usage:**
{ram_bar}
‚î£ Used: **{memory_used//1024//1024:,}MB** / **{memory_total//1024//1024:,}MB**
‚î£ Available: **{(memory_total-memory_used)//1024//1024:,}MB**
‚îó Percentage: **{memory_percent:.1f}%**

üíæ **Storage Usage:**
{disk_bar}
‚î£ Used: **{disk.used//1024//1024//1024:.1f}GB** / **{disk.total//1024//1024//1024:.1f}GB**
‚îó Free: **{disk.free//1024//1024//1024:.1f}GB**

üåê **Network Activity:**
‚î£ üì§ Sent: **{bytes_sent//1024//1024:.1f}MB**
‚î£ üì• Received: **{bytes_recv//1024//1024:.1f}MB**
‚îó üìä Packets: **{packets_sent + packets_recv:,}**

‚ö° **System Info:**
‚î£ üìà Processes: **{processes}**
‚î£ ‚è∞ Uptime: **{str(uptime).split('.')[0]}**
‚îó üïê Updated: **{datetime.now().strftime('%H:%M:%S')}**
            """
            
            keyboard = [
                [
                    InlineKeyboardButton("üîÑ Refresh", callback_data="sysinfo"),
                    InlineKeyboardButton("üìà Detailed Stats", callback_data="detailed_stats")
                ],
                [
                    InlineKeyboardButton("üìä Process Manager", callback_data="process_manager"),
                    InlineKeyboardButton("üßπ System Cleanup", callback_data="cleanup_system")
                ],
                [InlineKeyboardButton("üîô Main Menu", callback_data="main_menu")]
            ]
            
            await query.edit_message_text(
                message,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='Markdown'
            )
            
        except Exception as e:
            await query.edit_message_text(
                f"‚ùå **System Monitor Error**\n\n`{str(e)}`",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("üîô Main Menu", callback_data="main_menu")
                ]]),
                parse_mode='Markdown'
            )
    
    def create_progress_bar(self, percentage, length=20, emoji="‚ñà"):
        """Create enhanced progress bar with emoji"""
        filled = int((percentage / 100) * length)
        bar = emoji * filled + "‚ñë" * (length - filled)
        
        # Color coding based on percentage
        if percentage < 30:
            status = "üü¢"
        elif percentage < 70:
            status = "üü°"
        else:
            status = "üî¥"
            
        return f"`{bar}` {status} **{percentage:.1f}%**"
    
    async def show_file_manager(self, query):
        try:
            files = []
            dirs = []
            
            # Get directory contents
            for item in os.listdir(self.current_directory):
                path = os.path.join(self.current_directory, item)
                try:
                    if os.path.isdir(path):
                        dirs.append(item)
                    else:
                        files.append(item)
                except PermissionError:
                    continue
            
            dirs.sort()
            files.sort()
            
            # Limit display
            display_dirs = dirs[:8]
            display_files = files[:8]
            
            file_list = ""
            
            if display_dirs:
                file_list += "üìÅ **Directories:**\n"
                for d in display_dirs:
                    try:
                        item_count = len(os.listdir(os.path.join(self.current_directory, d)))
                        file_list += f"‚î£ üìÅ `{d}` ({item_count} items)\n"
                    except:
                        file_list += f"‚î£ üìÅ `{d}` (protected)\n"
                file_list += "\n"
            
            if display_files:
                file_list += "üìÑ **Files:**\n"
                for f in display_files:
                    size = self.get_file_size(os.path.join(self.current_directory, f))
                    ext = os.path.splitext(f)[1].lower()
                    icon = self.get_file_icon(ext)
                    file_list += f"‚î£ {icon} `{f}` ({size})\n"
            
            if not display_dirs and not display_files:
                file_list = "üì≠ **Directory is empty**"
            
            # Show hidden file count
            hidden_dirs = len([d for d in dirs if d.startswith('.')]) if len(dirs) > 8 else 0
            hidden_files = len([f for f in files if f.startswith('.')]) if len(files) > 8 else 0
            
            summary = f"\nüìä **Summary:** {len(dirs)} dirs, {len(files)} files"
            if hidden_dirs or hidden_files:
                summary += f" (+{hidden_dirs + hidden_files} hidden)"
            
            message = f"""
üìÅ **ADVANCED FILE MANAGER**
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìç **Current Path:**
`{self.current_directory}`

{file_list}{summary}

üîß **Quick Actions:**
‚î£ üì§ Upload files to current directory
‚î£ üì• Download files from current directory  
‚î£ üóúÔ∏è Compress/Extract archives
‚î£ üîç Search files and directories
‚îó üìä Analyze disk usage
            """
            
            keyboard = [
                [
                    InlineKeyboardButton("üè† Home", callback_data="go_home"),
                    InlineKeyboardButton("‚¨ÜÔ∏è Parent", callback_data="go_parent"),
                    InlineKeyboardButton("üîÑ Refresh", callback_data="files")
                ],
                [
                    InlineKeyboardButton("üì§ Upload", callback_data="upload_file"),
                    InlineKeyboardButton("üì• Download", callback_data="download_file"),
                    InlineKeyboardButton("üóúÔ∏è Archive", callback_data="compress_files")
                ],
                [
                    InlineKeyboardButton("üîç Search", callback_data="search_files"),
                    InlineKeyboardButton("üìä Disk Usage", callback_data="disk_usage")
                ],
                [
                    InlineKeyboardButton("üíª Terminal", callback_data="terminal"),
                    InlineKeyboardButton("üîô Main Menu", callback_data="main_menu")
                ]
            ]
            
            await query.edit_message_text(
                message,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='Markdown'
            )
            
        except Exception as e:
            await query.edit_message_text(
                f"‚ùå **File Manager Error**\n\n`{str(e)}`",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("üîô Main Menu", callback_data="main_menu")
                ]]),
                parse_mode='Markdown'
            )
    
    def get_file_icon(self, ext):
        """Get appropriate icon for file type"""
        icons = {
            '.py': 'üêç', '.js': 'üìú', '.html': 'üåê', '.css': 'üé®',
            '.jpg': 'üñºÔ∏è', '.png': 'üñºÔ∏è', '.gif': 'üñºÔ∏è', '.mp4': 'üé¨',
            '.mp3': 'üéµ', '.wav': 'üéµ', '.pdf': 'üìÑ', '.txt': 'üìù',
            '.zip': 'üóúÔ∏è', '.tar': 'üóúÔ∏è', '.gz': 'üóúÔ∏è', '.apk': 'üì±',
            '.deb': 'üì¶', '.rpm': 'üì¶', '.exe': '‚öôÔ∏è', '.sh': 'üìã',
            '.json': 'üìã', '.xml': 'üìã', '.log': 'üìä', '.db': 'üóÑÔ∏è'
        }
        return icons.get(ext, 'üìÑ')
    
    def get_file_size(self, filepath):
        """Get human readable file size"""
        try:
            size = os.path.getsize(filepath)
            for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
                if size < 1024:
                    return f"{size:.1f}{unit}"
                size /= 1024
            return f"{size:.1f}PB"
        except:
            return "Unknown"
    
    async def show_network_tools(self, query):
        message = f"""
üåê **ADVANCED NETWORK TOOLS**
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üîç **Network Analysis:**
‚î£ üåê **Network Scanner** - Discover devices
‚î£ üîå **Port Scanner** - Check open ports  
‚î£ üìä **Speed Test** - Internet performance
‚î£ üì° **WiFi Analyzer** - Network details
‚îó üåç **Public IP Info** - Location & ISP

‚ö° **Connection Tools:**
‚î£ üèì **Ping & Traceroute** - Network testing
‚î£ üîó **DNS Lookup** - Domain resolution
‚î£ üì± **Device Info** - Network interfaces
‚îó üõ°Ô∏è **Security Scan** - Vulnerability check

üöÄ **Professional Features:**
‚î£ üìà **Bandwidth Monitor** - Real-time usage
‚î£ üåê **HTTP Server** - Create local server
‚î£ üîê **VPN Status** - Connection details
‚îó üìä **Network Statistics** - Detailed metrics

üí° **Select a network tool:**
        """
        
        keyboard = [
            [
                InlineKeyboardButton("üåê Network Scan", callback_data="scan_network"),
                InlineKeyboardButton("üîå Port Scan", callback_data="check_ports")
            ],
            [
                InlineKeyboardButton("üìä Speed Test", callback_data="speed_test"),
                InlineKeyboardButton("üì° WiFi Info", callback_data="wifi_info")
            ],
            [
                InlineKeyboardButton("üèì Ping Test", callback_data="ping_test"),
                InlineKeyboardButton("üîó DNS Lookup", callback_data="dns_lookup")
            ],
            [
                InlineKeyboardButton("üåç Public IP", callback_data="public_ip"),
                InlineKeyboardButton("üìà Bandwidth", callback_data="bandwidth_monitor")
            ],
            [InlineKeyboardButton("üîô Main Menu", callback_data="main_menu")]
        ]
        
        await query.edit_message_text(
            message,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
    
    async def show_nonroot_tools(self, query):
        message = f"""
üîì **NON-ROOT POWER TOOLS**
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

‚ú® **Advanced Features Without Root:**

üìä **System Analysis:**
‚î£ üîç **Process Inspector** - Detailed process info
‚î£ üìà **Performance Monitor** - CPU, RAM, I/O
‚î£ üå°Ô∏è **Temperature Monitor** - Device thermal
‚îó üîã **Battery Optimizer** - Power management

üõ†Ô∏è **System Utilities:**
‚î£ üßπ **Smart Cleaner** - Cache & temp files
‚î£ üì¶ **Package Manager** - Install/remove apps
‚î£ üîß **Service Controller** - Manage services
‚îó üìä **Log Analyzer** - System diagnostics

üåê **Network & Security:**
‚î£ üîê **Security Scanner** - Vulnerability check
‚î£ üåê **Network Monitor** - Traffic analysis
‚î£ üõ°Ô∏è **Firewall Status** - Security overview
‚îó üîí **Encryption Tools** - File protection

üì± **Device Management:**
‚î£ üîä **Audio Control** - Volume & sound
‚î£ üí° **Display Settings** - Brightness & screen
‚î£ üì≥ **Notification Manager** - Alert control
‚îó üîÑ **Auto Tasks** - Scheduled operations

üí™ **Powerful Alternatives:**
‚î£ ‚úÖ **ADB Commands** - Advanced debugging
‚î£ üêç **Python Scripts** - Custom automation
‚î£ üîß **Shell Utilities** - Command line tools
‚îó üìã **Batch Operations** - Multiple commands

üéØ **Choose your tool:**
        """
        
        keyboard = [
            [
                InlineKeyboardButton("üîç Process Inspector", callback_data="process_inspector"),
                InlineKeyboardButton("üìà Performance", callback_data="performance_monitor")
            ],
            [
                InlineKeyboardButton("üßπ Smart Cleaner", callback_data="smart_cleaner"),
                InlineKeyboardButton("üì¶ Package Mgr", callback_data="package_manager")
            ],
            [
                InlineKeyboardButton("üîê Security Scan", callback_data="security_scan"),
                InlineKeyboardButton("üõ°Ô∏è Encryption", callback_data="encryption_tools")
            ],
            [
                InlineKeyboardButton("üîä Audio Control", callback_data="audio_control"),
                InlineKeyboardButton("üì≥ Notifications", callback_data="notification_mgr")
            ],
            [
                InlineKeyboardButton("üêç Python Scripts", callback_data="python_scripts"),
                InlineKeyboardButton("üìã Batch Ops", callback_data="batch_operations")
            ],
            [InlineKeyboardButton("üîô Main Menu", callback_data="main_menu")]
        ]
        
        await query.edit_message_text(
            message,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
    
    async def show_security_tools(self, query):
        message = f"""
üõ°Ô∏è **SECURITY & ENCRYPTION CENTER**
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üîê **Encryption & Protection:**
‚î£ üîí **File Encryption** - AES-256 protection
‚î£ üóùÔ∏è **Password Generator** - Secure passwords
‚î£ üì± **QR Code Generator** - Secure sharing
‚îó üîê **Hash Calculator** - File integrity

üõ°Ô∏è **Security Analysis:**
‚î£ üîç **Vulnerability Scan** - System security
‚î£ üåê **Network Security** - Connection analysis
‚î£ üìä **Permission Audit** - App permissions
‚îó üö® **Threat Detection** - Malware scan

üîí **Privacy Tools:**
‚î£ üßπ **Privacy Cleaner** - Remove traces
‚î£ üìÇ **Secure Delete** - Permanent removal
‚î£ üïµÔ∏è **Steganography** - Hidden messages
‚îó üíæ **Secure Backup** - Encrypted storage

‚ö° **Advanced Features:**
‚î£ üîë **SSH Key Manager** - Secure access
‚î£ üåê **Proxy Tools** - Anonymous browsing
‚î£ üì± **Device Lock** - Remote security
‚îó üîÑ **Auto Security** - Scheduled scans

üí° **Select security tool:**
        """
        
        keyboard = [
            [
                InlineKeyboardButton("üîí Encrypt Files", callback_data="encrypt_files"),
                InlineKeyboardButton("üóùÔ∏è Gen Password", callback_data="gen_password")
            ],
            [
                InlineKeyboardButton("üì± QR Generator", callback_data="qr_generator"),
                InlineKeyboardButton("üîê Hash Calc", callback_data="hash_calculator")
            ],
            [
                InlineKeyboardButton("üîç Vuln Scan", callback_data="vuln_scan"),
                InlineKeyboardButton("üõ°Ô∏è Network Sec", callback_data="network_security")
            ],
            [
                InlineKeyboardButton("üßπ Privacy Clean", callback_data="privacy_clean"),
                InlineKeyboardButton("üìÇ Secure Delete", callback_data="secure_delete")
            ],
            [
                InlineKeyboardButton("üîë SSH Keys", callback_data="ssh_keys"),
                InlineKeyboardButton("üì± Device Lock", callback_data="device_lock")
            ],
            [InlineKeyboardButton("üîô Main Menu", callback_data="main_menu")]
        ]
        
        await query.edit_message_text(
            message,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
    
    async def show_package_manager(self, query):
        message = f"""
üì¶ **SMART PACKAGE MANAGER**
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üöÄ **Package Operations:**
‚î£ üì• **Install Packages** - Add new software
‚î£ üîÑ **Update System** - Keep everything current
‚î£ üóëÔ∏è **Remove Packages** - Clean unneeded apps
‚îó üîç **Search Packages** - Find new tools

üìä **System Analysis:**
‚î£ üìã **Installed Packages** - View all installed
‚î£ üíæ **Package Sizes** - Disk usage analysis
‚î£ üîó **Dependencies** - Package relationships
‚îó üßπ **Cleanup System** - Remove orphaned files

‚ö° **Advanced Features:**
‚î£ üì± **APK Manager** - Install/manage APKs
‚î£ üêç **Python Packages** - pip management
‚î£ üåê **Repository Manager** - Source management
‚îó üì¶ **Package Backup** - Save configurations

üõ†Ô∏è **Popular Packages:**
```bash
# Development Tools
pkg install git vim nano python nodejs

# Network Tools  
pkg install nmap wget curl openssh

# System Utils
pkg install htop tree file unzip

# Media Tools
pkg install ffmpeg imagemagick youtube-dl
```

üí° **Choose package operation:**
        """
        
        keyboard = [
            [
                InlineKeyboardButton("üì• Install", callback_data="pkg_install"),
                InlineKeyboardButton("üîÑ Update", callback_data="pkg_update")
            ],
            [
                InlineKeyboardButton("üóëÔ∏è Remove", callback_data="pkg_remove"),
                InlineKeyboardButton("üîç Search", callback_data="pkg_search")
            ],
            [
                InlineKeyboardButton("üìã List Installed", callback_data="pkg_list"),
                InlineKeyboardButton("üíæ Package Sizes", callback_data="pkg_sizes")
            ],
            [
                InlineKeyboardButton("üì± APK Manager", callback_data="apk_manager"),
                InlineKeyboardButton("üêç Python Packages", callback_data="pip_manager")
            ],
            [
                InlineKeyboardButton("üßπ Cleanup", callback_data="pkg_cleanup"),
                InlineKeyboardButton("üì¶ Backup", callback_data="pkg_backup")
            ],
            [InlineKeyboardButton("üîô Main Menu", callback_data="main_menu")]
        ]
        
        await query.edit_message_text(
            message,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
    
    async def show_camera_pro(self, query):
        if not self.termux_api:
            await self.show_api_guide(query)
            return
            
        message = f"""
üì∑ **PROFESSIONAL CAMERA CONTROL**
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üì∏ **Camera Features:**
‚î£ üì∑ **Quick Photo** - Instant capture
‚î£ üé¨ **Video Recording** - HD video capture
‚î£ üîÑ **Camera Switch** - Front/back cameras
‚îó ‚öôÔ∏è **Camera Settings** - Advanced controls

üé® **Image Processing:**
‚î£ üñºÔ∏è **Photo Effects** - Filters & editing
‚î£ üìè **Resize Images** - Optimize size
‚î£ üîÑ **Format Convert** - Change file types
‚îó üìä **Image Analysis** - EXIF data & stats

‚ö° **Advanced Features:**
‚î£ ‚è∞ **Time-lapse** - Automated photography
‚î£ üì± **QR Code Scan** - Decode QR codes
‚î£ üîç **Object Detection** - AI analysis
‚îó üì§ **Auto Upload** - Cloud integration

üéØ **Professional Options:**
‚î£ üåü **HDR Mode** - High dynamic range
‚î£ üåô **Night Mode** - Low light capture
‚î£ üìê **Grid Lines** - Composition aid
‚îó üé≠ **Portrait Mode** - Depth effects

üí° **Select camera function:**
        """
        
        keyboard = [
            [
                InlineKeyboardButton("üì∑ Quick Photo", callback_data="quick_photo"),
                InlineKeyboardButton("üé¨ Record Video", callback_data="record_video")
            ],
            [
                InlineKeyboardButton("üîÑ Switch Camera", callback_data="switch_camera"),
                InlineKeyboardButton("‚öôÔ∏è Settings", callback_data="camera_settings")
            ],
            [
                InlineKeyboardButton("üñºÔ∏è Photo Effects", callback_data="photo_effects"),
                InlineKeyboardButton("üìè Resize Image", callback_data="resize_image")
            ],
            [
                InlineKeyboardButton("‚è∞ Time-lapse", callback_data="timelapse"),
                InlineKeyboardButton("üì± QR Scan", callback_data="qr_scan")
            ],
            [
                InlineKeyboardButton("üåü HDR Mode", callback_data="hdr_mode"),
                InlineKeyboardButton("üåô Night Mode", callback_data="night_mode")
            ],
            [InlineKeyboardButton("üîô Main Menu", callback_data="main_menu")]
        ]
        
        await query.edit_message_text(
            message,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
    
    async def show_sensors(self, query):
        if not self.termux_api:
            await self.show_api_guide(query)
            return
            
        message = f"""
üìç **GPS & SENSORS CENTER**
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üåç **Location Services:**
‚î£ üìç **GPS Location** - Precise coordinates
‚î£ üó∫Ô∏è **Address Lookup** - Reverse geocoding
‚î£ üìä **Location History** - Track movements
‚îó üéØ **Geofencing** - Location alerts

üì± **Device Sensors:**
‚î£ üß≠ **Compass** - Magnetic direction
‚î£ üìê **Accelerometer** - Motion detection
‚î£ üå°Ô∏è **Temperature** - Device thermal
‚îó üí° **Light Sensor** - Ambient lighting

‚ö° **Advanced Features:**
‚î£ üõ∞Ô∏è **Satellite Info** - GPS satellites
‚î£ üìà **Sensor Graphs** - Real-time plotting
‚î£ üîî **Motion Alerts** - Movement detection
‚îó üìä **Data Logging** - Sensor recording

üöÄ **Professional Tools:**
‚î£ üéØ **Navigation** - GPS navigation
‚î£ üìè **Distance Calc** - Between coordinates
‚î£ üåê **Altitude Info** - Elevation data
‚îó ‚è∞ **Time Sync** - GPS time sync

üí° **Select sensor tool:**
        """
        
        keyboard = [
            [
                InlineKeyboardButton("üìç GPS Location", callback_data="gps_location"),
                InlineKeyboardButton("üó∫Ô∏è Address Lookup", callback_data="address_lookup")
            ],
            [
                InlineKeyboardButton("üß≠ Compass", callback_data="compass"),
                InlineKeyboardButton("üìê Accelerometer", callback_data="accelerometer")
            ],
            [
                InlineKeyboardButton("üå°Ô∏è Temperature", callback_data="temperature"),
                InlineKeyboardButton("üí° Light Sensor", callback_data="light_sensor")
            ],
            [
                InlineKeyboardButton("üõ∞Ô∏è Satellite Info", callback_data="satellite_info"),
                InlineKeyboardButton("üìà Sensor Graphs", callback_data="sensor_graphs")
            ],
            [
                InlineKeyboardButton("üéØ Navigation", callback_data="navigation"),
                InlineKeyboardButton("üìè Distance Calc", callback_data="distance_calc")
            ],
            [InlineKeyboardButton("üîô Main Menu", callback_data="main_menu")]
        ]
        
        await query.edit_message_text(
            message,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
    
    async def show_settings(self, query):
        auth_count = len(self.authorized_users)
        
        message = f"""
‚öôÔ∏è **BOT CONFIGURATION CENTER**
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

ü§ñ **Bot Status:**
‚î£ Status: {'üü¢ Active' if self.bot_active else 'üî¥ Inactive'}
‚î£ Version: **v2.0 Professional**
‚î£ Uptime: **{datetime.now().strftime('%H:%M:%S')}**
‚îó Commands: **{len(self.command_history)}** executed

üîê **Security Settings:**
‚î£ Authorized Users: **{auth_count if auth_count > 0 else 'All users'}**
‚î£ Root Access: **{'‚úÖ Available' if self.root_available else '‚ùå Not Available'}**
‚î£ Termux API: **{'‚úÖ Active' if self.termux_api else '‚ùå Not Installed'}**
‚îó Device Admin: **{'‚úÖ Active' if self.admin_features else '‚ùå Limited'}**

üìÅ **System Settings:**
‚î£ Working Dir: `{os.path.basename(self.current_directory)}`
‚î£ Logs: **termux_bot.log**
‚î£ Config: **bot_config.json**
‚îó Storage: **{self.get_dir_size('.')} MB used**

‚ö° **Feature Status:**
‚î£ File Manager: **‚úÖ Active**
‚î£ Network Tools: **‚úÖ Active**  
‚î£ Security Center: **‚úÖ Active**
‚îó Package Manager: **‚úÖ Active**

üõ†Ô∏è **Configuration Options:**
        """
        
        keyboard = [
            [
                InlineKeyboardButton("üë• User Management", callback_data="user_management"),
                InlineKeyboardButton("üîß Bot Settings", callback_data="bot_settings")
            ],
            [
                InlineKeyboardButton("üìä View Logs", callback_data="view_logs"),
                InlineKeyboardButton("üßπ Clear Data", callback_data="clear_data")
            ],
            [
                InlineKeyboardButton("üîÑ Restart Bot", callback_data="restart_bot"),
                InlineKeyboardButton("üì§ Export Config", callback_data="export_config")
            ],
            [
                InlineKeyboardButton("üîß Install API", callback_data="install_api"),
                InlineKeyboardButton("‚ö° Diagnostics", callback_data="diagnostics")
            ],
            [InlineKeyboardButton("üîô Main Menu", callback_data="main_menu")]
        ]
        
        await query.edit_message_text(
            message,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
    
    def get_dir_size(self, path):
        """Get directory size in MB"""
        try:
            total = 0
            for dirpath, dirnames, filenames in os.walk(path):
                for f in filenames:
                    fp = os.path.join(dirpath, f)
                    try:
                        total += os.path.getsize(fp)
                    except:
                        pass
            return round(total / (1024 * 1024), 2)
        except:
            return 0
    
    async def show_help(self, query):
        message = f"""
üìñ **TERMUX BOT v2.0 - HELP CENTER**
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üöÄ **Getting Started:**
‚î£ üíª **Terminal Pro** - Execute any command
‚î£ üìÅ **File Manager** - Browse & manage files
‚î£ üìä **System Monitor** - Check performance
‚îó üåê **Network Tools** - Network analysis

üîß **Advanced Features:**
‚î£ üõ°Ô∏è **Security Center** - Encryption & protection
‚î£ üì¶ **Package Manager** - Install/manage software
‚î£ üì∑ **Camera Pro** - Professional photography
‚îó üì± **Device Control** - Hardware management

üí° **Pro Tips:**
‚î£ Use `cd ~` to go to home directory
‚î£ Use `ls -la` for detailed file listing
‚î£ Install Termux:API for hardware features
‚î£ Enable root for advanced system access
‚îó Authorize users for security

üÜò **Troubleshooting:**
‚î£ **Permission Denied**: Check file permissions
‚î£ **Command Not Found**: Install required package
‚î£ **API Error**: Install and configure Termux:API
‚î£ **Root Required**: Some features need root access
‚îó **Bot Slow**: Check system resources

üìã **Common Commands:**
```bash
# System Info
neofetch
htop
df -h

# Package Management
pkg update && pkg upgrade
pkg install [package]
pkg search [term]

# File Operations
ls -la
cp source dest
mv old new
rm file
```

üîó **Useful Links:**
‚î£ **Termux Wiki**: https://wiki.termux.com
‚î£ **Package List**: https://packages.termux.org
‚î£ **Termux:API**: F-Droid store
‚îó **GitHub Issues**: Report bugs

üí¨ **Need More Help?**
Contact the bot administrator or check logs for detailed error information.
        """
        
        keyboard = [
            [
                InlineKeyboardButton("üöÄ Quick Start", callback_data="quick_start"),
                InlineKeyboardButton("üîß Setup Guide", callback_data="setup_guide")
            ],
            [
                InlineKeyboardButton("üí° Pro Tips", callback_data="pro_tips"),
                InlineKeyboardButton("üÜò Troubleshoot", callback_data="troubleshoot")
            ],
            [
                InlineKeyboardButton("üìã Commands", callback_data="command_help"),
                InlineKeyboardButton("üîó Resources", callback_data="resources")
            ],
            [InlineKeyboardButton("üîô Main Menu", callback_data="main_menu")]
        ]
        
        await query.edit_message_text(
            message,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
    
    async def handle_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        if not self.is_authorized(user_id):
            await update.message.reply_text("üö´ Access denied")
            return
            
        command = update.message.text.strip()
        
        # Add to command history
        self.command_history.append(command)
        if len(self.command_history) > self.max_history:
            self.command_history.pop(0)
        
        try:
            # Handle special commands
            if command.startswith('cd '):
                await self.handle_cd_command(update, command)
                return
            elif command in ['clear', 'cls']:
                await update.message.reply_text("üßπ **Terminal cleared**", parse_mode='Markdown')
                return
            elif command == 'history':
                await self.show_command_history(update)
                return
            elif command.startswith('sudo ') and not self.root_available:
                await update.message.reply_text(
                    "‚ö†Ô∏è **Root not available**\n\nTrying non-root alternative...", 
                    parse_mode='Markdown'
                )
                # Try without sudo
                command = command[5:]
            
            # Execute command with enhanced output
            start_time = time.time()
            
            result = subprocess.run(
                command, 
                shell=True, 
                cwd=self.current_directory,
                capture_output=True, 
                text=True, 
                timeout=60  # Increased timeout
            )
            
            execution_time = time.time() - start_time
            
            # Process output
            stdout = result.stdout
            stderr = result.stderr
            
            if stdout or stderr:
                output = ""
                if stdout:
                    output += f"üì§ **Output:**\n```\n{stdout}\n```\n"
                if stderr:
                    output += f"‚ö†Ô∏è **Errors:**\n```\n{stderr}\n```\n"
                
                # Add execution info
                output += f"‚è±Ô∏è **Execution time:** {execution_time:.2f}s\n"
                output += f"üìä **Exit code:** {result.returncode}"
                
                # Limit output size
                if len(output) > 4000:
                    output = output[:4000] + "\n... *(output truncated)*"
                
                await update.message.reply_text(output, parse_mode='Markdown')
            else:
                await update.message.reply_text(
                    f"‚úÖ **Command executed successfully**\n‚è±Ô∏è Time: {execution_time:.2f}s\nüìä Exit code: {result.returncode}",
                    parse_mode='Markdown'
                )
            
        except subprocess.TimeoutExpired:
            await update.message.reply_text("‚è∞ **Command timeout** (60 seconds limit)")
        except Exception as e:
            await update.message.reply_text(f"‚ùå **Error:** `{str(e)}`", parse_mode='Markdown')
    
    async def handle_cd_command(self, update, command):
        """Enhanced cd command handler"""
        path = command[3:].strip()
        
        if not path:
            path = '~'
        
        if path == '~':
            new_path = os.path.expanduser('~')
        elif path == '-':
            # Go to previous directory (if we had one stored)
            new_path = getattr(self, 'previous_directory', os.path.expanduser('~'))
        elif path == '..':
            new_path = os.path.dirname(self.current_directory)
        elif path.startswith('/'):
            new_path = path
        else:
            new_path = os.path.join(self.current_directory, path)
        
        try:
            if os.path.exists(new_path) and os.path.isdir(new_path):
                self.previous_directory = self.current_directory
                self.current_directory = os.path.abspath(new_path)
                
                # Get directory info
                try:
                    items = os.listdir(self.current_directory)
                    file_count = len([f for f in items if os.path.isfile(os.path.join(self.current_directory, f))])
                    dir_count = len([d for d in items if os.path.isdir(os.path.join(self.current_directory, d))])
                except PermissionError:
                    file_count = dir_count = "?"
                
                await update.message.reply_text(
                    f"üìÅ **Directory changed**\n\n"
                    f"üìç **Path:** `{self.current_directory}`\n"
                    f"üìä **Contents:** {dir_count} directories, {file_count} files",
                    parse_mode='Markdown'
                )
            else:
                await update.message.reply_text(f"‚ùå **Directory not found:** `{path}`", parse_mode='Markdown')
        except PermissionError:
            await update.message.reply_text(f"üö´ **Permission denied:** `{path}`", parse_mode='Markdown')
    
    async def show_command_history(self, update):
        """Show command history"""
        if not self.command_history:
            await update.message.reply_text("üìù **Command history is empty**", parse_mode='Markdown')
            return
        
        history_text = "üìú **COMMAND HISTORY**\n" + "="*30 + "\n\n"
        
        for i, cmd in enumerate(self.command_history[-10:], 1):
            history_text += f"`{i:2d}.` `{cmd}`\n"
        
        if len(self.command_history) > 10:
            history_text += f"\n... and {len(self.command_history) - 10} more commands"
        
        await update.message.reply_text(history_text, parse_mode='Markdown')
    
    # Placeholder methods for additional features
    async def scan_network(self, query):
        await query.edit_message_text("üåê Network scanning feature - Coming soon!")
    
    async def check_ports(self, query):
        await query.edit_message_text("üîå Port scanning feature - Coming soon!")
    
    async def network_speed_test(self, query):
        await query.edit_message_text("üìä Speed test feature - Coming soon!")
    
    async def show_wifi_info(self, query):
        await query.edit_message_text("üì° WiFi info feature - Coming soon!")
    
    async def show_process_manager(self, query):
        await query.edit_message_text("üìä Process manager - Coming soon!")
    
    async def show_service_manager(self, query):
        await query.edit_message_text("üîß Service manager - Coming soon!")
    
    async def show_log_viewer(self, query):
        await query.edit_message_text("üìã Log viewer - Coming soon!")
    
    async def cleanup_system(self, query):
        await query.edit_message_text("üßπ System cleanup - Coming soon!")
    
    async def handle_file_upload(self, query):
        await query.edit_message_text("üì§ File upload feature - Coming soon!")
    
    async def handle_file_download(self, query):
        await query.edit_message_text("üì• File download feature - Coming soon!")
    
    async def compress_files(self, query):
        await query.edit_message_text("üóúÔ∏è File compression - Coming soon!")
    
    async def backup_system(self, query):
        await query.edit_message_text("üíæ System backup - Coming soon!")
    
    def run(self):
        """Run the bot"""
        print("\n" + "üî•"*60)
        print("üöÄ TERMUX BOT CONTROLLER v2.0 - PROFESSIONAL EDITION")
        print("üî•"*60)
        print("‚ö° Initializing advanced systems...")
        print(f"üìÅ Working Directory: {self.current_directory}")
        print(f"üì± Termux API: {'‚úÖ Available' if self.termux_api else '‚ùå Not Available'}")
        print(f"üëë Root Access: {'‚úÖ Available' if self.root_available else '‚ùå Not Available'}")
        print(f"üõ°Ô∏è Device Admin: {'‚úÖ Available' if self.admin_features else '‚ùå Limited Access'}")
        print("üî•"*60)
        
        try:
            app = Application.builder().token(self.bot_token).build()
            
            # Add handlers
            app.add_handler(CommandHandler("start", self.start_command))
            app.add_handler(CallbackQueryHandler(self.button_handler))
            app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_command))
            
            print("‚úÖ Bot initialized successfully!")
            print("üí¨ Send /start in Telegram to begin")
            print("üéØ All features ready for professional use")
            print("üîÑ Press Ctrl+C to stop the bot")
            print("üî•"*60)
            
            app.run_polling(drop_pending_updates=True)
            
        except KeyboardInterrupt:
            print("\nüõë Bot shutting down gracefully...")
            print("üëã Thanks for using Termux Bot Controller v2.0!")
        except Exception as e:
            print(f"‚ùå Critical Error: {e}")
            logger.error(f"Bot crashed: {e}")

if __name__ == "__main__":
    try:
        bot = AdvancedTermuxBot()
        bot.run()
    except Exception as e:
        print(f"üö´ Failed to start bot: {e}")
        sys.exit(1)
